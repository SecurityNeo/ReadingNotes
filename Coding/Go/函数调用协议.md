# 函数调用协议 #

[https://www.w3cschool.cn/go_internals/go_internals-27ok282k.html](https://www.w3cschool.cn/go_internals/go_internals-27ok282k.html)

## 关键字：go ##

[@chenkai](https://juejin.im/user/59ef54625188252c23120ead)大牛的[剖析golang的25个关键字](https://juejin.im/post/5b43674d5188251b176a4c8b)很值得一看。

表达式`go f(x, y, z)`会启动一个新的goroutine运行函数`f(x, y, z)`。函数f，变量x、y、z的值是在原goroutine计算，只有函数f的执行是在新的goroutine中。新的goroutine不能和当前go线程用同一个栈，否则会相互覆盖。所以对go关键字的调用协议与普通函数调用是不同的。

来看下面两道比较有意思的题：

1、

```golang
func main() {
    runtime.GOMAXPROCS(1)
    for i := 0; i < 10; i++ {
        go println(i)
    }
    runtime.Gosched()
    time.Sleep(time.Second)
}
```

运行结果： 9 0 1 2 3 4 5 6 7 8

2、

```golang
func main() {
    runtime.GOMAXPROCS(1)
    for i := 0; i < 10; i++ {
        go func() {
            println(i)
        }()
    }
    runtime.Gosched()
    time.Sleep(time.Second)
}
```

运行结果： 十个10

**解析：**

首先`runtime. GOMAXPROCS(1)`强行指定了只创建一个“P”来处理并发，例子中的10个goroutine是串行执行的。对比上面两道题，区别在 “go” 关键字后的函数。对于计算机而言，goroutine只是语言封装的语法糖，对于计算机依旧是识别指令及内存里的值。我们需要记住：编译器会把go后面的方法和参数打包在goroutine里，运行到go的时候，编译器就已经把goroutine需要运行的参数与方法都保存了下来，对于示例1来说就是保存了`{ println, current_i }`，而示例2保存的是`{ main.func_xxx, nil }`。

对于示例1，为什么输出的不是0~9？go在把goroutine放入队列的时候还做了一件很特别的事：proc:4756 (next)，代码内容如下：

```golang
if next {
retryNext:
	oldnext := _p_.runnext
	if !_p_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) {
		goto retryNext
	}
	if oldnext == 0 {
		return
	}
	// Kick the old runnext out to the regular run queue.
	gp = oldnext.ptr()
}
```

意思是go会把每个P所管理的最后一个goroutine放入next位置。如果一个P的goroutine队列在顺序执行的时候，因为go sched会有很多抢占或者调度。那么从被执行的概率上来分析的话，放入一个next位置可使得每个goroutine的执行概率是相当的。(有点懵逼，怎么都没读懂)

我们把示例1中的`runtime.Gosched()`注释掉，其运行结果就是: 0 1 2 3 4 5 6 7 8 9

## 关键字：defer ##

defer用于资源的释放，会在函数返回之前进行调用。如果有多个defer表达式，调用顺序类似于栈，越后面的defer表达式越先被调用。在使用defer时需要搞清楚函数返回的过程：先给返回值赋值，然后调用defer表达式，最后才是返回到调用函数中。
使用defer时，用一个简单的转换规则改写一下，就不会迷糊了。改写规则是将return语句拆成两句写，return xxx会被改写成:
```
返回值 = xxx
调用defer函数
空的return
```

文章里有三个示例：

1、

```golang
func f() (result int) {
    defer func() {
        result++
    }()
    return 0
}
```
返回值：1

2、
```golang
func f() (r int) {
     t := 5
     defer func() {
       t = t + 5
     }()
     return t
}
```
返回值：5

3、
```golang
func f() (r int) {
    defer func(r int) {
          r = r + 5
    }(r)
    return 1
}
```
返回值：1
