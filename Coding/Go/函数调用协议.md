# 函数调用协议 #

## 关键字：go ##

表达式`go f(x, y, z)`会启动一个新的goroutine运行函数`f(x, y, z)`。函数f，变量x、y、z的值是在原goroutine计算，只有函数f的执行是在新的goroutine中。新的goroutine不能和当前go线程用同一个栈，否则会相互覆盖。所以对go关键字的调用协议与普通函数调用是不同的。

来看下面两道比较有意思的题：

1、

```golang
func main() {
    runtime.GOMAXPROCS(1)
    for i := 0; i < 10; i++ {
        go println(i)
    }
    runtime.Gosched()
    time.Sleep(time.Second)
}
```

运行结果： 9 0 1 2 3 4 5 6 7 8

2、

```golang
func main() {
    runtime.GOMAXPROCS(1)
    for i := 0; i < 10; i++ {
        go func() {
            println(i)
        }()
    }
    runtime.Gosched()
    time.Sleep(time.Second)
}
```

运行结果： 十个10

**解析：**

首先`runtime. GOMAXPROCS(1)`强行指定了只创建一个“P”来处理并发，例子中的10个goroutine是串行执行的。对比上面两道题，区别在 “go” 关键字后的函数。对于计算机而言，goroutine只是语言封装的语法糖，对于计算机依旧是识别指令及内存里的值。我们需要记住：编译器会把go后面的方法和参数打包在goroutine里，运行到go的时候，编译器就已经把goroutine需要运行的参数与方法都保存了下来，对于示例1来说就是保存了`{ println, current_i }`，而示例2保存的是`{ main.func_xxx, nil }`。

对于示例1，为什么输出的不是0~9？go在把goroutine放入队列的时候还做了一件很特别的事：proc:4756 (next)，代码内容如下：

```golang
if next {
retryNext:
	oldnext := _p_.runnext
	if !_p_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) {
		goto retryNext
	}
	if oldnext == 0 {
		return
	}
	// Kick the old runnext out to the regular run queue.
	gp = oldnext.ptr()
}
```

意思是go会把每个P所管理的最后一个goroutine放入next位置。如果一个P的goroutine队列在顺序执行的时候，因为go sched会有很多抢占或者调度。那么从被执行的概率上来分析的话，放入一个next位置可使得每个goroutine的执行概率是相当的。(有点懵逼，怎么都没读懂)

我们把示例1中的`runtime.Gosched()`注释掉，其运行结果就是: 0 1 2 3 4 5 6 7 8 9